# Binary Search and log\(n\) problems

## 小结



二分或者log\(n\)基本算是o\(n\)以下最优的解法了（除了特殊几种）。 应用场景包括如下：

* 二分搜索
* 二分查找分界点（OOXX\)
* 二分答案



### 二分搜索

二分搜索有其固定的模板，这个在题目中已经有所体现， 比较tricky的地方是通过

A\[mid\] 与target等于号的比较来找第一个和最后一个的问题， A\[mid\] &gt;= target beg = mid, 则A最后的指向一定是最后一个，A\[mid\]&lt;=target, end = mid, 最后的指向是第一个。 



二分搜索里面比较有代表性的是搜索rotated array那两道题目， 二分不一定非要分中间，而是应该分自己确定的部分，每次砍掉能砍掉的部分， 比如a\[mid\] &gt; beg的情况，证明 \[beg, target, mid\]可以确定，则砍掉这部分或者查找这部分而其余的要一一分清很麻烦。 另外一种就是a\[mid\] &lt; beg, 同理麻烦的在 rotate的位子，我们呼略不管他，而只关心\[mid, target, end\]的情况。 搞懂这道题目算是对二分搜索理解的最深的了。



### 二分查找

二分查找算是一种找边界的问题， 例如找rotated array 拐点， 找第一个bad version 等等， 满足左面true, 右面false的情况， 保持两边向中间渐进的一种解法。 一般问题都很显而易见。

比较典型的是first bad version或者find peak



###  二分答案

二分答案的题目只能意会不能言传了，首先难点在于找到是用二分答案来解决， 有三道题目： 最大子数组均值：这道题要找到一个A使得所有子数组中最大的和要小于A\*n（子数组）， 如果A可以满足，则A可以减小，不满足A可以变大，最终停留在一个介乎满足与不满足条件中。 砍树和抄书问题也是。 但这类题目有个共性就是要求连续数组中的最优解\(最大或最小）。 而解决其中的子问题： 判断true or false通常又很有挑战性。  



### 非主流

prime factoring： 我个人觉得不是二分，网上的答案我没看懂，但这道题目记得一个结论， 分解因子要从小到大进行，而且mod是用来判定是否为整除的判定

drop eggs: 有一道数学题， 记住一个结论， 就是从1一直加到x使得 和大于等于n 为什么记住 x，输了从 1开始扔到x-1, 如果赢了x+x-1,开始扔，一直lucky, x+....x-1+1 = n  x 是这个二分点， 最后其实程序解决的问题是x\(x+1\)/2 =n的解

divide two integers: 这道题目难点在与用2^n做泰勒展开。 while\(d &gt;= tmp&lt;&lt;1\){ tmp&lt;&lt;=1, cout &lt;&lt;=1} d-=tmp, res+= count算是题眼吧。

search 2d matrix ii : 这道题目难点在于找规律，规律在于左下角和右上角，每次都可以排除掉一行，这样可以做到o\(n+m\) ,因为那两个位子算是所在行的最小最大位置， 如果当前小往上，比当前大往右走，相等对角线走。在中间的时候为啥不向左走？ 因为我们从最左面来， 如果一直比target小我们一直在左面， 而我们之所以能在中间是因为我们往右走了，就不应该再往左面走，因为左面只能比我们起始点位子更小。 













